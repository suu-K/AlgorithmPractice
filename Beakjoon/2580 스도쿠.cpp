/*
문제 : 스도쿠(https://www.acmicpc.net/problem/2580)
 스도쿠는 18세기 스위스 수학자가 만든 '라틴 사각형'이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다.
 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.
 나머지 빈 칸을 채우는 방식은 다음과 같다.

	각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
	굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
	위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.

 또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.
 이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.
 게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.


입력
 아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다.
 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.

출력
 모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.
 스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.

풀이
 백트랙킹을 이용한 완전탐색으로 알고리즘을 짜는 것은 쉬웠으나 자꾸 오답이 났었다.
 그 이유는 정답을 하나만 출력해야 하는 문제 특성 상 재귀함수를 끝까지 돌리면 여러 답을 거치게 되어버린 다는 것이다.
 따라서 최초에 답을 찾았으면 그 즉시 정답을 출력하고 프로그램을 종료하도록 해야 했다.
 */

#include <iostream>
#include <vector>

using namespace std;

struct point {	//좌표
	int x;
	int y;
	point(int x, int y) : x(x), y(y) {};
}typedef point;

int b[9][9];		//스도쿠 판
vector<point> v;	//빈칸의 좌표 저장용 벡터

void printB() {		//스도쿠 판 출력
	for (int y = 0; y < 9; y++) {
		for (int x = 0; x < 9; x++) {
			cout << b[y][x] << " ";
		}
		cout << endl;
	}
}

bool check(int y, int x, int n) {	//겹치는 숫자가 있는지 조사
	for (int i = 0; i < 9; i++) {	//가로 세로에 겹치는 숫자가 있는지 검사
		if (b[y][i] == n)
			return false;
		if (b[i][x] == n)
			return false;
	}
	int nx = (x / 3) * 3;
	int ny = (y / 3) * 3;
	for (int i = ny; i < ny + 3; i++)	//사각형 안에 겹치는 숫자가 있는지 검사
		for (int j = nx; j < nx + 3; j++)
			if (b[i][j] == n)
				return false;
	return true;
}

void solve(int idx) {
	if (idx == v.size()) {	//만일 빈칸을 다 채웠으면 출력후 프로그램 종료
		printB();
		exit(0);
	}
	for (int i = 1; i <= 9; i++) {	//빈칸에 1부터 9까지 하나씩 넣어가며 검사
		if (check(v[idx].y, v[idx].x, i)) {	//만일 겹치는 숫자가 없으면 넣고
			b[v[idx].y][v[idx].x] = i;
			solve(idx + 1);					//다음 빈칸을 채운다
		}
	}
	b[v[idx].y][v[idx].x] = 0;		//만일 맞는 수가 없다면 빈칸으로 되돌린다.
	return;
}



int main() {
	int tmp;
	int cnt = 0;
	for (int y = 0; y < 9; y++) {
		for (int x = 0; x < 9; x++) {
			cin >> tmp;
			if (tmp == 0)
				v.push_back(point(x, y));
			b[y][x] = tmp;
		}
	}
	solve(0);
	return 0;
}
